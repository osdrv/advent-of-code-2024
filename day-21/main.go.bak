package main

import (
	"strconv"
)

func parseNum(s string) int {
	n, err := strconv.Atoi(s[:len(s)-1])
	noerr(err)
	return n
}

var (
	NUMERIC = [][]byte{
		{'7', '8', '9'},
		{'4', '5', '6'},
		{'1', '2', '3'},
		{0, '0', 'A'},
	}

	DIRECTIONAL = [][]byte{
		{0, '^', 'A'},
		{'<', 'v', '>'},
	}
)

func precompute(F [][]byte) map[byte]map[byte]int {
	res := make(map[byte]map[byte]int)

	for i := 0; i < len(F); i++ {
		for j := 0; j < len(F[i]); j++ {
			if F[i][j] == 0 {
				continue
			}
			if _, ok := res[F[i][j]]; !ok {
				res[F[i][j]] = make(map[byte]int)
			}
			for m := 0; m < len(F); m++ {
				for n := 0; n < len(F[m]); n++ {
					if F[m][n] == 0 {
						continue
					}
					_, d, _ := findShortest(F, Point2{x: j, y: i}, F[m][n])
					res[F[i][j]][F[m][n]] = d
				}
			}
		}
	}

	return res
}

var (
	PREDIR = precompute(DIRECTIONAL)
)

type QItem struct {
	P    Point2
	D    int
	PATH []byte
}

var (
	PATH_MOVE = map[Point2]byte{
		{x: 1, y: 0}:  '>',
		{x: -1, y: 0}: '<',
		{x: 0, y: 1}:  'v',
		{x: 0, y: -1}: '^',
	}
)

func score(s string) int {
	if len(s) == 0 {
		return 0
	}
	sc := 0
	//sc := PREDIR['A'][s[0]]
	for i := 1; i < len(s); i++ {
		//sc += PREDIR[s[i-1]][s[i]]
		if s[i-1] != s[i] {
			sc += 1
		}
	}
	return sc
}

func findShortest(F [][]byte, p Point2, want byte) (Point2, int, [][]byte) {
	Q := make([]QItem, 0, 1)
	Q = append(Q, QItem{
		P:    p,
		D:    0,
		PATH: []byte{},
	})
	V := make(map[Point2]int)

	mind := ALOT
	minpaths := make([][]byte, 0, 1)
	var finish Point2
	var H QItem
	for len(Q) > 0 {
		H, Q = Q[0], Q[1:]
		if F[H.P.y][H.P.x] == want {
			if mind >= H.D {
				mind = H.D
				minpaths = append(minpaths, H.PATH)
				finish = H.P
			}
			continue
		}
		if prev, ok := V[H.P]; ok && prev < H.D {
			continue
		}
		V[H.P] = H.D
		for _, s := range STEPS4 {
			nx, ny := H.P.x+s[0], H.P.y+s[1]
			if nx < 0 || nx >= len(F[0]) || ny < 0 || ny >= len(F) || F[ny][nx] == 0 {
				continue
			}
			d := H.D + 1
			p := Point2{x: nx, y: ny}
			if prev, ok := V[p]; ok && prev < d {
				continue
			}
			path := make([]byte, len(H.PATH)+1)
			copy(path, H.PATH)
			path[len(path)-1] = PATH_MOVE[Point2{x: s[0], y: s[1]}]
			Q = append(Q, QItem{P: p, D: d, PATH: path})
		}
	}

	return finish, mind, minpaths
}

func processField(F [][]byte, start Point2, ss []string) []string {
	var paths [][]byte
	cands := make([]string, 0, 1)
	minlen := ALOT
	minscore := ALOT
	for _, s := range ss {
		res := []string{""}
		pos := start
		for i := 0; i < len(s); i++ {
			pos, _, paths = findShortest(F, pos, s[i])
			newres := make([]string, 0, len(res)*len(paths))
			for _, prevr := range res {
				for _, path := range paths {
					newres = append(newres, prevr+string(path)+"A")
				}
			}
			res = newres
		}

		for _, r := range res {
			cands = append(cands, r)
			minlen = min(minlen, len(r))
			minscore = min(minscore, score(r))
		}
	}

	ret := make([]string, 0, 1)
	mem := make(map[string]bool)
	for _, cand := range cands {
		if len(cand) > minlen {
			continue
		}
		if _, ok := mem[cand]; ok {
			continue
		}
		if score := score(cand); score > minscore {
			continue
		}
		mem[cand] = true
		ret = append(ret, cand)
	}

	return ret
}

// func processNumeric(s string) []string {
// 	res := make([]string, 0, 1)
// 	pos := Point2{x: 2, y: 3}
//
// 	var path []byte
// 	for i := 0; i < len(s); i++ {
// 		debugf("want: %c", s[i])
// 		pos, _, paths = findShortest(NUMERIC, pos, s[i])
//
// 		b.Write(path)
// 		b.WriteByte('A')
// 	}
//
// 	return res
// }
//
// func processDirectional(s string) string {
// 	var b strings.Builder
// 	pos := Point2{x: 2, y: 0}
//
// 	var path []byte
// 	for i := 0; i < len(s); i++ {
// 		debugf("want: %c", s[i])
// 		pos, _, path = findShortest(DIRECTIONAL, pos, s[i])
// 		debugf("shortest path: %s", string(path))
// 		b.Write(path)
// 		b.WriteByte('A')
// 	}
//
// 	return b.String()
// }

func parseN(s string) int {
	n, err := strconv.Atoi(s[:len(s)-1])
	noerr(err)
	return n
}

func main() {
	lines := input()
	debugf("file data: %+v", lines)

	score("^A^^<<A>>AvvvA")
	score("^A^<<^A>>AvvvA")
	score("^A<<^^A>>AvvvA")

	//debugf("prenum: %+v", PRENUM)
	//debugf("predir: %+v", PREDIR)

	res1 := 0
	for _, line := range lines {
		cmds := processField(NUMERIC, Point2{x: 2, y: 3}, []string{line})
		debugf("cmds: %+v", cmds)

		memo := make(map[string]string)
		for _, cmd := range cmds {
			debugf("cmd: %s -> %d", cmd, score(cmd))
		}

		// for i := 0; i < 3; i++ {
		// 	debugf("i: %d", i)
		// 	cmds = processField(DIRECTIONAL, Point2{x: 2, y: 0}, cmds[:1])
		// 	debugf("len(cmds): %d", len(cmds))
		// }
		// res1 += len(cmds[0]) * parseN(line)
		// debugf("%d * %d = %d", len(cmds[0]), parseN(line), len(cmds[0])*parseN(line))
	}

	printf("res1:%d", res1)
}
